/**
 * Regular Expression是一种文本模式 包含普通字符(a-z)和特殊字符(元字符)
 * 
 * 限定符
 * ？ 零个或一个
 * +  一个或多个
 * *  零个或多个
 * ^  开始位置
 * [0-9]+ 表示匹配多个数字
 * abc$ 以abc结尾的字符串
 * {n,}
 * {n, m}
 * ******************************************************
 * 
 * 1 测试字符串的模式
 * 2 替换文本
 * 3 基于模式匹配从字符串中提取子字符串
 * 
 * *****************************************************
 * 
 * 1 普通字符： 没有显示指定为元字符的所有可打印和不可打印字符，包括大小写字母，数字，标点符号，其他字符
 * 2 非打印字符：\cx 匹配由x指明的控制字符，x必须是A-Z或a-z 之一
 *              \f 换页符
 *              \n 换行符
 *              \r 回车符
 *              \s 任何空白符：空格，制表符，换页符，
 *              \S 非空白
 *              \t 制表符
 *              \v 垂直制表符
 * 3 特殊字符
 * $ 结尾位置
 * ^ 开始位置
 * () 子表达式的开始和结束位置
 * * 匹配前面子表达式零次或多次
 * + 匹配前面子表达式一次或多次
 * ？匹配前面子表达式零次或一次
 * . 匹配除换行符之外的任何单字符
 * [] 中括号的标记
 * {} 大括号的标记
 * | 两项中的一项
 * 
 * 4 限定符
 * 5 定位符
 *  ^
 *  $
 *  \b
 *  \B
 * 
 * 6 选择
 * 圆括号有副作用，可以使用? : 
 * ?:是非捕获元之一，还有两个非捕获元是 ?= 和 ?!
 * ?= 正向预查，在任何开始匹配的圆括号内的正则表达式模式的位置来匹配搜索字符串
 * ?! 负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串
 * 
 * 7 反向引用
 * 对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照
 * 在正则表达式模式中从左到右出现的顺序存储，
 * 可以使用非捕获元字符 ?:、?= 或 ?! 来重写捕获，忽略对相关匹配的保存
 * 反向引用的最简单最有用的应用之一是提供查找文本中两个相同的相邻的匹配项的能力
 * 
 * 
 * /\b([a-z]+) \1\b/ig;
 * 这是一个捕获的表达式，[a-z]+ 包括一个或多个字母，正则表达式的第二部分是对以前捕获的子匹配的引用，
 * 单词的第二个匹配项正好由括号表达式匹配，\1指定第一个子匹配项
 * 字符边界\b确保只检测整个单词
 * g表示匹配整个字符串，找出尽可能多的符合条件的子匹配项
 * i不分大小写
 * 多行标记指定换行符的两边可能出现潜在的匹配
 * 反向引用还可以将通用资源指示符(URI)分解为其组件
 * 
 * 
 * /(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)/
 * 第一个括号捕获web地址的协议部分，该子表达式匹配在冒号和两个正斜杠前面的任何单词
 * 第二个括号子表达式捕获地址的域地址，子表达式匹配 : 和 / 之后的一个或多个字符
 * 第三个括号子表达式捕获端口，该表达式捕获冒号后面的另个或多个数字，只能重复一次该表达式
 * 第四个括号子表达式捕获web地址指定的路径和/或页信息，该子表达式能匹配不包括#或空格字符的任何字符序列
 * 
 * 
 * 元字符
 * \转义字符
 * ^开始
 * $结束
 * *前面的子表达式零次或多次
 * +一次或多次
 * ？零次或一次
 * {n}确定n次
 * {n,}n次或多次
 * {n, m} n-m次
 * (pattern)匹配pattern并获取这一结果
 * (?:pattern)匹配pattern但不获取结果，也就是说这是一个非获取匹配，不进行存储供以后使用
 * (?=pattern) 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用
 * (?!pattern) 正向否定欲查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用
 * (?<=pattern) 反向(look behind)肯定预查，与正向肯定预查相反，只是方向相反
 * (?<!pattern) 反向否定预查，与反向肯定相反
 * x|y 匹配x或y z|food' 能匹配 "z" 或 "food"。'(z|f)ood' 则匹配 "zood" 或 "food"
 * [xyz]匹配所以包含的任意一个字符，[abc]可以匹配plain中的a
 * [^xyz]匹配未包含的任意字符，[^abc]可以匹配plain中的p l i n
 * [a-z]匹配a-z中的任意字符
 * [^a-z]匹配任何不在指定范围内的字符
 * \b 单词的边界，单词和空格间的位置，
 * \B 非单词的边界，
 * \cx 匹配由x指明的控制字符，
 * \d 数字
 * \D 非数字
 * \f 换页符
 * \n 换行符
 * \r 回车符
 * \t 制表符
 * \s 空白符
 * \S 非空白符
 * \v 垂直制表符
 * \w 字母 数字 下划线 [A-Za-z0-9_]
 * \W 非
 * \xn 匹配n，n 为16位进制，
 * \num 匹配num 对所获取的匹配的引用， (.)\1匹配两个连续的相同字符
 * \n 标识一个八进制转义值或一个向后引用
 * 
 * 正则表达式优先级
 * \
 * (), (?:), (?=), []
 * *, +, ?, {n}, {n,}, {n, m}
 * ^, $, \任何字符
 * |
 * 
 * 基本匹配模式
 * ^once 以once开头的字符串
 * bucket$ 以bucket结尾的字符串
 * once 只要包含就匹配
 * 
 * 字符簇
 * [AaEeOoIiUu]取出字符串中第一个元音，只能匹配一个字符
 * [a-z]字符范围 但是也是匹配出一个
 * ^[a-z][0-9]$
 * ^放在方括号里面的话表示非，外面的话表示开头
 * 特殊字符(.)表示除了新行之外的所有字符
 * 
 * 确定重复的出现
 * 出现的次数使用花括号来限定
 * ^[a-zA-Z_]$所有的字母和下划线
 * ^[[:alpha]]{3}$
 * 
 * 简单表达式
 * /1/, /b/
 * /abc/
 * 
 * 字符匹配
 * (.)匹配所有除了\n之外的字符，
 * 
 * 中括号表达式
 * 括在中括号表达式中的字符只匹配处于正则表达式中该位置的单个字符
 */